<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STARK Benchmark Visualizer</title>
    <!-- Bootstrap for UI -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Plotly.js for graphs -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- PapaParse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { padding: 20px; }
        .plot-container { height: 400px; margin: 20px 0; }
        select[multiple] { height: 150px; }
        #errorMsg { color: red; display: none; }
        .form-check { margin-top: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive STARK Benchmark Visualizer</h1>
        <p>Select variants to plot one dataset per variant (all arities grouped as base + .x over k). Arity multi-select filters within variants. k-range filters dynamically.</p>
        <div id="errorMsg" class="alert alert-warning">No data loaded or arities found. Check console for details.</div>

        <!-- Controls -->
        <div class="row mb-3">
            <div class="col-md-3">
                <label for="machineSelect" class="form-label">Machine Type (CSV File)</label>
                <select id="machineSelect" class="form-select">
                    <!-- Populated by JS -->
                </select>
            </div>
            <div class="col-md-3">
                <label for="variantSelect" class="form-label">Variants - Multi-select for Comparison (One Dataset per Variant)</label>
                <select id="variantSelect" class="form-select" multiple>
                    <option value="">All Variants</option>
                    <!-- Populated by JS -->
                </select>
            </div>
            <div class="col-md-3">
                <label for="aritySelect" class="form-label">Arities (Filter within Variants) - Multi-select</label>
                <select id="aritySelect" class="form-select" multiple>
                    <!-- Populated by JS -->
                </select>
            </div>
            <div class="col-md-3">
                <label class="form-label">k Range (Filters Datasets)</label>
                <div class="row">
                    <div class="col-6">
                        <input type="number" id="kMin" class="form-control" value="11" min="11" max="25" step="1" placeholder="Min k">
                    </div>
                    <div class="col-6">
                        <input type="number" id="kMax" class="form-control" value="25" min="11" max="25" step="1" placeholder="Max k">
                    </div>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="groupSimilar">
                    <label class="form-check-label" for="groupSimilar">Group extensions under base (one line per variant)</label>
                </div>
            </div>
        </div>
        <button id="updateBtn" class="btn btn-primary mb-3">Update Graphs</button>

        <!-- Graphs -->
        <div id="proofSizePlot" class="plot-container"></div>
        <div id="proverTimePlot" class="plot-container"></div>
        <div id="verifyTimePlot" class="plot-container"></div>
        <div id="elemsPerSPlot" class="plot-container"></div>
    </div>

    <script>
        // Configuration: Update with all 9 CSVs
        const csvUrls = [
            { label: 'T4G Micro (Rayon R52 2 cores 1GB, Pallas, SHA3)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-micro-t4g-rayon-r52-1gb-fullprotocol-dual-hash-pallas-sha3-e3.csv' },
            { label: 'T4G Micro (Rayon R52 2 cores 1GB, Goldilocks, keccak)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-micro-t4g-rayon-r52-1gb-fullprotocol-dual-hash-golidlocks-keccak-e3.csv'
              },
             { label: 'AVX512.xlarge rayon R52 8 cores 8GB, Goldilocks, blake3)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-c5-avx512-xlarge-r52-fullprotocol-dual-hash-goldilocks-blake3-e3.csv' },
            { label: 'T4G Micro (Rayon R52 2 cores 1GB, Pallas, blake3)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-micro-t4g-rayon-r52-1gb-fullprotocol-dual-hash-pallas-blake3-e3.csv' },
            { label: 'T4G Micro (Rayon R52 2 cores 1GB, Pallas, keccak)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-micro-t4g-rayon-r52-1gb-fullprotocol-dual-hash-pallas-keccak-e3.csv' },
            { label: 'T4G Micro (Rayon R52 2 cores 1GB, Goldilocks, SHA3)', url: 'https://raw.githubusercontent.com/saholmes/stark-has/main/results/final-micro-t4g-rayon-r52-1gb-fullprotocol-dual-hash-golidlocks-sha3-e3.csv' },
        
            // Add the other 7 here once uploaded
        ];

        let allData = {};

        // Parse schedule: Base from first values, + .x for extensions
        function parseSchedule(scheduleStr, variant = null, isBase = false) {
            if (!scheduleStr || typeof scheduleStr !== 'string') return null;
            let cleanedStr = scheduleStr.replace(/^"|"$/g, '').trim();
            cleanedStr = cleanedStr.replace(/[\[\]\s]/g, '');
            const cleaned = cleanedStr.split(',').map(num => parseInt(num.trim())).filter(n => !isNaN(n));
            if (cleaned.length < 2) return { array: [], label: scheduleStr.substring(0, 20) + '...', seriesLabel: scheduleStr, original: scheduleStr };
            
            let baseArray = cleaned.slice(0, 3); // Base: First 3 (your pattern)
            let baseLabel = baseArray.join(','); // e.g., "16,16,8"
            if (cleaned.every(n => n === cleaned[0])) {
                baseLabel = `${cleaned[0]}x${cleaned.length}`;
            } else if (cleaned.length > 3 && cleaned.slice(0, cleaned.length - 1).every(n => n === cleaned[0])) {
                baseLabel = `${cleaned[0]}x${cleaned.length - 1}`;
            }
            let arityLabel = isBase ? baseLabel : `${baseLabel}.x`;
            let seriesLabel = variant ? `${variant}: [${arityLabel}]` : `[${arityLabel}]`;
            let shortLabel = seriesLabel.length > 25 ? seriesLabel.substring(0, 22) + '...' : seriesLabel;
            return { 
                array: cleaned, 
                label: shortLabel,
                seriesLabel: seriesLabel,
                baseLabel: baseLabel,
                isExtended: cleaned.length > 3,
                original: scheduleStr 
            };
        }

        // Get base label for a variant (first schedule's base + .x for full dataset)
        function getVariantBaseLabel(machineLabel, variant) {
            const machineData = allData[machineLabel];
            if (!machineData) return '';
            const variantRows = machineData.originalRows.filter(row => row.label === variant);
            if (variantRows.length === 0) return '';
            const firstSchedule = variantRows[0].schedule;
            const parsed = parseSchedule(firstSchedule, variant, true); // isBase=true for first
            return parsed ? parsed.seriesLabel.replace(']', '.x]') : variant; // Append .x for extensions
        }

        // Load CSVs (unchanged)
        async function loadData() {
            const machineSelect = document.getElementById('machineSelect');
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.style.display = 'none';

            for (const { label, url } of csvUrls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${url}`);
                    const csvText = await response.text();
                    console.log(`Fetched ${label} (${url}): ${csvText.length} chars`);
                    
                    const results = Papa.parse(csvText, { header: true, skipEmptyLines: true, dynamicTyping: false });
                    console.log(`Raw parsed data length for ${label}: ${results.data.length}. Sample raw row:`, results.data[0] || 'None');
                    
                    const originalRows = results.data
                        .map((row, index) => {
                            if (index === 0) console.log(`Cleaning first row for ${label}:`, row);
                            Object.keys(row).forEach(key => {
                                if (row[key] === '' || row[key] === undefined || row[key] === null) row[key] = null;
                                if (['k', 'proof_bytes', 'prove_s', 'verify_ms', 'prove_elems_per_s'].includes(key)) {
                                    row[key] = parseFloat(row[key]);
                                }
                                if (row.schedule) {
                                    row.parsedSchedule = parseSchedule(row.schedule);
                                    if (index === 0) console.log(`Parsed first schedule: ${row.schedule} ->`, row.parsedSchedule);
                                }
                            });
                            return row;
                        })
                        .filter(row => row.k && !isNaN(row.k) && row.parsedSchedule && row.parsedSchedule.array.length >= 2 && row.label);

                    console.log(`Cleaned rows for ${label}: ${originalRows.length}. Sample cleaned row:`, originalRows[0] || 'None');

                    const parsedArities = {};
                    originalRows.forEach(row => {
                        const sch = row.parsedSchedule;
                        if (sch && !parsedArities[sch.original]) {
                            parsedArities[sch.original] = sch;
                        }
                    });

                    allData[label] = { originalRows, parsedArities };
                    const uniqueVariants = [...new Set(originalRows.map(row => row.label).filter(v => v && v !== 'csv'))];
                    console.log(`Loaded ${label}: ${originalRows.length} rows. Variants: [${uniqueVariants.join(', ')}]. Sample schedule: ${JSON.stringify(originalRows[0]?.parsedSchedule)}`);

                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    machineSelect.appendChild(option);
                } catch (err) {
                    console.error(`Error loading ${label} (${url}):`, err);
                    errorMsg.textContent += `\nFailed to load ${label}: ${err.message}. Check URL and upload file.`;
                    errorMsg.style.display = 'block';
                }
            }
        }

        // Get unique variants (unchanged)
        function getUniqueVariants(machineLabel) {
            const machineData = allData[machineLabel];
            if (!machineData) return [];
            const variants = [...new Set(machineData.originalRows.map(row => row.label).filter(v => v && v !== 'csv'))];
            console.log(`Unique variants for ${machineLabel}:`, variants);
            return variants.sort();
        }

        // Get arities for dropdown (within selected variants)
        function getUniqueArities(machineLabel, selectedVariants = [], groupSimilar = false) {
            const machineData = allData[machineLabel];
            if (!machineData) return [];
            let filteredRows = machineData.originalRows.filter(row => row.parsedSchedule && row.parsedSchedule.array.length >= 2);
            if (selectedVariants.length > 0 && !selectedVariants.includes('')) {
                filteredRows = filteredRows.filter(row => selectedVariants.includes(row.label));
            }
            if (filteredRows.length === 0) return [];

            const schedulesByVariant = {};
            filteredRows.forEach(row => {
                const v = row.label;
                if (!schedulesByVariant[v]) schedulesByVariant[v] = new Set();
                schedulesByVariant[v].add(row.schedule);
            });

            const individuals = [];
            Object.entries(schedulesByVariant).forEach(([v, schedulesSet]) => {
                schedulesSet.forEach(schStr => {
                    const parsed = parseSchedule(schStr, v);
                    if (parsed) individuals.push(parsed);
                });
            });
            individuals.sort((a, b) => a.seriesLabel.localeCompare(b.seriesLabel));

            if (groupSimilar) {
                const groups = {};
                individuals.forEach(parsed => {
                    const base = parsed.array[0];
                    if (!groups[base]) groups[base] = [];
                    groups[base].push(parsed);
                });
                if (Object.keys(groups).length > 0) return groups;
            }

            console.log(`Arity labels for variants [${selectedVariants.join(', ')}]: [${individuals.slice(0, 5).map(p => p.label).join(', ')}...]`);
            return individuals;
        }

        // Update variant dropdown (multi-select, auto-select first 2)
        function updateVariantDropdown(machineLabel) {
            const variantSelect = document.getElementById('variantSelect');
            variantSelect.innerHTML = '<option value="">All Variants</option>';
            const variants = getUniqueVariants(machineLabel);
            variants.forEach(variant => {
                const option = document.createElement('option');
                option.value = variant;
                option.textContent = variant;
                variantSelect.appendChild(option);
            });
            if (variants.length > 0) {
                variantSelect.options[1].selected = true;
                if (variants.length > 1) variantSelect.options[2].selected = true;
                const selectedVariants = Array.from(variantSelect.selectedOptions).map(opt => opt.value).filter(v => v);
                updateArityDropdown(machineLabel, selectedVariants, document.getElementById('groupSimilar').checked);
            }
        }

        // Update arity dropdown (filters within variants)
        function updateArityDropdown(machineLabel, selectedVariants, groupSimilar) {
            const aritySelect = document.getElementById('aritySelect');
            aritySelect.innerHTML = '';
            let arities = getUniqueArities(machineLabel, selectedVariants, groupSimilar);

            if (groupSimilar && typeof arities === 'object' && Object.keys(arities).length === 0) {
                arities = getUniqueArities(machineLabel, selectedVariants, false);
                groupSimilar = false;
            }

            let hasOptions = false;
            if (groupSimilar && typeof arities === 'object') {
                Object.entries(arities).forEach(([base, group]) => {
                    const option = document.createElement('option');
                    option.value = `group-${base}`;
                    option.textContent = `All ${base}-based in selected variants (${group.length})`;
                    aritySelect.appendChild(option);
                    hasOptions = true;
                });
                const totalIndiv = Object.values(arities).flat().length;
                if (totalIndiv <= 15) {
                    const optGroup = document.createElement('optgroup');
                    optGroup.label = 'Specific arities in selected variants:';
                    Object.values(arities).flat().forEach(parsed => {
                        const option = document.createElement('option');
                        option.value = parsed.original;
                        option.textContent = parsed.label;
                        option.title = parsed.original;
                        optGroup.appendChild(option);
                    });
                    aritySelect.appendChild(optGroup);
                    hasOptions = true;
                }
            } else if (Array.isArray(arities) && arities.length > 0) {
                arities.forEach(parsed => {
                    const option = document.createElement('option');
                    option.value = parsed.original;
                    option.textContent = parsed.label;
                    option.title = parsed.original;
                    aritySelect.appendChild(option);
                    hasOptions = true;
                });
            }

            if (!hasOptions) {
                const option = document.createElement('option');
                option.value = 'all';
                option.textContent = 'All arities in selected variants';
                aritySelect.appendChild(option);
            }

            const options = Array.from(aritySelect.querySelectorAll('option:not(optgroup)'));
            const numToSelect = Math.min(options.length, 3);
            for (let i = 0; i < numToSelect; i++) {
                options[i].selected = true;
            }
            if (hasOptions && options.length > 0) {
                updateGraphs();
            } else {
                document.getElementById('errorMsg').textContent = `No arities found for ${machineLabel} (variants: [${selectedVariants.join(', ')}]). Check console.`;
                document.getElementById('errorMsg').style.display = 'block';
            }
        }

        // Event listeners (unchanged for multi-select)
        document.getElementById('machineSelect').addEventListener('change', (e) => {
            const machineLabel = e.target.value;
            if (!machineLabel) return;
            updateVariantDropdown(machineLabel);
        });

        document.getElementById('variantSelect').addEventListener('change', (e) => {
            const machineLabel = document.getElementById('machineSelect').value;
            const selectedVariants = Array.from(e.target.selectedOptions).map(opt => opt.value).filter(v => v && v !== '');
            console.log('Selected variants:', selectedVariants);
            const groupSimilar = document.getElementById('groupSimilar').checked;
            updateArityDropdown(machineLabel, selectedVariants, groupSimilar);
        });

        document.getElementById('groupSimilar').addEventListener('change', (e) => {
            const machineLabel = document.getElementById('machineSelect').value;
            const selectedVariants = Array.from(document.getElementById('variantSelect').selectedOptions).map(opt => opt.value).filter(v => v && v !== '');
            updateArityDropdown(machineLabel, selectedVariants, e.target.checked);
        });

        // Update graphs: One dataset/line per variant (all arities grouped), filtered by k-range
        document.getElementById('updateBtn').addEventListener('click', updateGraphs);
        document.getElementById('kMin').addEventListener('input', updateGraphs);
        document.getElementById('kMax').addEventListener('input', updateGraphs);

        function updateGraphs() {
            const machineLabel = document.getElementById('machineSelect').value;
            const variantSelect = document.getElementById('variantSelect');
            const selectedVariants = Array.from(variantSelect.selectedOptions).map(opt => opt.value).filter(v => v && v !== '');
            const selectedOptions = Array.from(document.getElementById('aritySelect').selectedOptions);
            const groupSimilar = document.getElementById('groupSimilar').checked;
            const kMinInput = document.getElementById('kMin').value.trim();
            const kMaxInput = document.getElementById('kMax').value.trim();
            let kMin = parseInt(kMinInput) || 11;
            let kMax = parseInt(kMaxInput) || 25;
            if (kMin > kMax) [kMin, kMax] = [kMax, kMin];
            console.log(`Update triggered: variants [${selectedVariants.join(', ')}], k range ${kMin}-${kMax}`);

            if (!machineLabel) return;

            const machineData = allData[machineLabel];
            if (!machineData) return;

            let targetSchedules = selectedOptions.map(opt => opt.value).filter(v => v && v !== 'all');
            if (groupSimilar) {
                targetSchedules = targetSchedules.flatMap(val => {
                    if (val.startsWith('group-')) {
                        const base = parseInt(val.split('-')[1]);
                        const groups = getUniqueArities(machineLabel, selectedVariants, true);
                        return groups[base]?.map(p => p.original) || [];
                    }
                    return val;
                });
            }

            // If no specific arities selected, use all from selected variants (full dataset per variant)
            if (targetSchedules.length === 0) {
                targetSchedules = []; // Will use all per variant below
            }

            // Filter base data for selected variants and k-range
            let filteredData = machineData.originalRows.filter(row => 
                (selectedVariants.length === 0 || selectedVariants.includes(row.label)) &&
                parseInt(row.k) >= kMin && parseInt(row.k) <= kMax
            );

            if (targetSchedules.length > 0) {
                // Filter to specific arities
                filteredData = filteredData.filter(row => targetSchedules.includes(row.schedule));
            }

            console.log(`Filtered: ${filteredData.length} rows for variants [${selectedVariants.join(', ')}]${targetSchedules.length > 0 ? `, specific arities [${targetSchedules.slice(0,3)}...]` : ''}, k range ${kMin}-${kMax}. Available k: [${[...new Set(filteredData.map(r => r.k))].sort((a,b)=>a-b).join(', ')}]`);

            if (filteredData.length === 0) {
                console.warn('No matching data. Try selecting variants or wider k range.');
                return;
            }

            const tracesByVariant = {}; // One trace per variant (grouped dataset)

            // Group data by variant
            const dataByVariant = {};
            filteredData.forEach(row => {
                const v = row.label;
                if (!dataByVariant[v]) dataByVariant[v] = [];
                dataByVariant[v].push(row);
            });

            Object.entries(dataByVariant).forEach(([variant, variantData]) => {
                if (targetSchedules.length > 0) {
                    // Filter to specific arities within variant
                    variantData = variantData.filter(row => targetSchedules.includes(row.schedule));
                }
                if (variantData.length === 0) return;

                // Sort by k for progression line
                variantData.sort((a, b) => parseInt(a.k) - parseInt(b.k));
                const kVals = variantData.map(row => parseInt(row.k));
                const baseLabel = getVariantBaseLabel(machineLabel, variant); // Base + .x
                const seriesName = groupSimilar ? `${variant}: ${baseLabel} (grouped)` : baseLabel;

                tracesByVariant[seriesName] = {
                    k: kVals,
                    proofBytes: variantData.map(row => row.proof_bytes),
                    proveS: variantData.map(row => row.prove_s),
                    verifyMs: variantData.map(row => row.verify_ms),
                    proveElemsPerS: variantData.map(row => row.prove_elems_per_s)
                };
                console.log(`Dataset for ${seriesName}: ${kVals.length} points over k=[${kVals.join(', ')}], using arities [${variantData.slice(0,3).map(r => r.schedule).join(', ')}...]`);
            });

            if (Object.keys(tracesByVariant).length === 0) return;

            function plotData(divId, traces, title, yKey) {
                const plotTraces = Object.entries(traces).map(([name, vals]) => ({
                    x: vals.k,
                    y: vals[yKey],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: name,  // e.g., "paper: [16,16,8].x"
                    line: { shape: 'linear' }
                }));
                Plotly.newPlot(divId, plotTraces, {
                    title: title,
                    xaxis: { title: 'k' },
                    yaxis: { title: yKey.replace(/([A-Z])/g, ' $1').trim() }
                });
            }

            plotData('proofSizePlot', tracesByVariant, 'Proof Size (bytes) vs. k', 'proofBytes');
            plotData('proverTimePlot', tracesByVariant, 'Prover Time (s) vs. k', 'proveS');
            plotData('verifyTimePlot', tracesByVariant, 'Verify Time (ms) vs. k', 'verifyMs');
            plotData('elemsPerSPlot', tracesByVariant, 'Prover Elements per Second vs. k', 'proveElemsPerS');
        }

        // Init
        loadData().then(() => {
            if (csvUrls.length > 0) {
                setTimeout(() => {
                    const machineSelect = document.getElementById('machineSelect');
                    if (machineSelect.options.length > 0) {
                        machineSelect.selectedIndex = 0;
                        machineSelect.dispatchEvent(new Event('change'));
                        document.getElementById('groupSimilar').checked = false;
                    }
                }, 3000);
            }
        });
    </script>
</body>
</html>